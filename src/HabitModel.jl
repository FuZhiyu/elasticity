
module HabitModel

include("utils.jl")
export HabitParameters, HabitHouseholds, solveR!, iteratepolicy!, iterationhelper!
export calculatepd!, ùîºM
export @unpack_HabitParameters, @unpack_HabitHouseholds

@with_kw struct HabitParameters
    @deftype Float64
    Œ≤ = 0.93^0.25
    œÉy = 0.0086/2
    g = 0.022/4 # + 0.5 * œÉy^2
    Œ≥ = 2
    # habit parameters
    œÜ = 0.89^0.25
    b = 0.011
    SÃÑ = œÉy * ‚àö(Œ≥/(1-œÜ-b/Œ≥))
    sÃÑ = log(SÃÑ)
    s‚Çò‚Çê‚Çì = sÃÑ + 1/2 * (1 - SÃÑ^2)
    S‚Çò‚Çê‚Çì = exp(s‚Çò‚Çê‚Çì)
    œà = 0.2
    agrid::Vector{Float64} = 1 .+ [exp(x) - 1 for x in 0.0:0.01:5] # starting from 1.0 
    na::Int64 = length(agrid)
    # Sgrid::Vector{Float64} = [[1e-5 * 5; 1e-4 * 5; 1e-4 * ; 1e-3 * 5]; range(0.0, S‚Çò‚Çê‚Çì, length = 10)[2:end-1]; S‚Çò‚Çê‚Çì .- 1e-4 .- [0.003:-0.001:0;]; S‚Çò‚Çê‚Çì]
    nshigh::Int64 = 10
    nslow::Int64 = 10
    slowmin = -20
    sgridhigh::Vector{Float64} =  log.(range(0.0, stop = S‚Çò‚Çê‚Çì, length = nshigh))
    sgridlow::Vector{Float64} = range(slowmin, stop = sgridhigh[2], length = nslow)
    sgrid::Vector{Float64} = [sgridlow[1:end-1]; sgridhigh[2:end]]
    Sgrid::Vector{Float64} = exp.(sgrid)
    # sgrid::Vector{Float64} = log.(Sgrid)
    ns::Int64 = length(Sgrid)
    ùîºŒµy::IterableExpectation{Array{Float64,1},Array{Float64,1}} = expectation(Normal(), Gaussian; n=40)
    Rfvec::Vector{Float64} = zeros(ns)
    pdvec::Vector{Float64} = ones(ns) * 10.0
    ùîºR::Vector{Float64} = zeros(ns)
end

#===================================================
#       Aggregate functions
===================================================#

@inline function Œªfunc(s, param::HabitParameters)
    @unpack sÃÑ, s‚Çò‚Çê‚Çì, SÃÑ = param
    if s > s‚Çò‚Çê‚Çì
        return zero(s)
    end
    return 1/SÃÑ * ‚àö(1-2(s-sÃÑ)) - 1
end


@inline function Œîsfunc(s, Œµy, param)
    @unpack œÜ, sÃÑ, œÉy = param
    Œª = Œªfunc(s, param)
    return (1-œÜ) * (sÃÑ - s) + Œª * œÉy * Œµy
end

s‚Ä≤func(s, Œµy, param) = s + Œîsfunc(s, Œµy, param)

@inline function Œîyfunc(Œµy, param)
    @unpack œÉy, g = param
    return g + œÉy * Œµy
end

@inline function Rfunc(s, Œµy, param)
    @unpack pdvec, sgrid, Sgrid = param
    s‚Ä≤ = s‚Ä≤func(s, Œµy, param)
    # pd = linear_interp(sgrid, pdvec, s, true, false)
    # pd‚Ä≤ = linear_interp(sgrid, pdvec, s‚Ä≤, true, false)
    pd = linear_interp(Sgrid, pdvec, exp(s), true, false)
    pd‚Ä≤ = linear_interp(Sgrid, pdvec, exp(s‚Ä≤), true, false)
    Œîy = Œîyfunc(Œµy, param)
    return (pd‚Ä≤ + 1) / pd * exp(Œîy)
end

@inline function Mfunc(s, Œµy, param)
    @unpack Œ≤, Œ≥ = param
    Œîs = Œîsfunc(s, Œµy, param)
    Œîy = Œîyfunc(Œµy, param)
    return exp(-Œ≥ * (Œîs+Œîy)) * Œ≤
end

function ùîºM(s, param)
    return param.ùîºŒµy(Œµy -> Mfunc(s, Œµy, param))
end

@inline function assetpricing(s, Œµy, param)
    M = Mfunc(s, Œµy, param)
    R = Rfunc(s, Œµy, param)
    return M * R - 1
end

@inline function ùîºassetpricing(s, param)
    return param.ùîºŒµy(Œµy -> assetpricing(s, Œµy, param))
end

function solvepd_helper(pdguess, param)
    param.pdvec .= pdguess
    return ùîºassetpricing.(param.sgrid, Ref(param))
end

function pditeration_inner(Fvec, s, Œµy, param)
    @unpack_HabitParameters param
    M = Mfunc(s, Œµy, param)
    Œîy = Œîyfunc(Œµy, param)
    s‚Ä≤ = s‚Ä≤func(s, Œµy, param)
    S‚Ä≤ = exp(s‚Ä≤)
    # F = linear_interp(sgrid, Fvec, s‚Ä≤, true, false)    
    # F = linear_interp(Sgrid, Fvec, S‚Ä≤, true, false)
    if S‚Ä≤ < 0.005
        F = linear_interp(sgrid, Fvec, s‚Ä≤, true, false)
    else
        F = linear_interp(Sgrid, Fvec, S‚Ä≤, true, false)
    end
    return M * exp(Œîy) * F
end

function ùîºpditeration(Fvec, s, param)
     return param.ùîºŒµy(Œµy -> pditeration_inner(Fvec, s, Œµy, param))
end

function iterateF!(Fnew, Fvec, param)
    @unpack sgrid = param
    Fnew .= ùîºpditeration.(Ref(Fvec), sgrid, Ref(param))
    return Fnew
end

function calculatepd!(param; iterations = 1000)
    @unpack_HabitParameters param
    Fvec = ones(size(sgrid))
    Fnew = similar(Fvec)
    pdvec .= Fvec
    counter = 0
    while (counter < iterations) && norm(Fvec) > 1e-8
        iterateF!(Fnew, Fvec, param)
        pdvec .+= Fnew
        Fvec .= Fnew
    end
    for is in 1:ns
        ùîºR[is] = ùîºŒµy(Œµy-> Rfunc(sgrid[is], Œµy, param))
    end
    Rfvec .= 1 ./ ùîºM.(sgrid, Ref(param))
    return pdvec
end

#===================================================
#       Bellman equation infrastructure
===================================================#

@with_kw struct HabitHouseholds{T <: Real}
    # the first dimension for the matricies is w, and the second is the state variable z
    Vmat::Matrix{T} # value function
    # V‚Ä≤mat::Matrix{T} # value function
    Vamat::Matrix{T} # value function
    Œ∏mat::Matrix{T} # portfolio allocation
    Œ∏ÃÉmat::Matrix{T} # portfolio allocation by wÃÉ
    cmat::Matrix{T} # consumption
    wmat::Matrix{T} # used for endogenous points
    wÃÉmat::Matrix{T} # used for endogenous points
    # Œ∏ÃÉmat::Matrix{T} # store temporary value
end

function HabitHouseholds(param, T=Float64; initializeHH=true)
    @unpack_HabitParameters param
    mats =  [Matrix{T}(undef, na, ns) for i in 1:length(fieldnames(HabitHouseholds))]
    hh = HabitHouseholds(mats...)
    if initializeHH
        initializeHH!(hh, param)
    end
    return hh
end

@inline @fastmath function Œ∏focŒµy(Œ∏, wÃÉ, is, Œµy, funcs, param::HabitParameters)
    @unpack_HabitParameters param
    @unpack Vafunc = funcs
    s = sgrid[is]
    s‚Ä≤ = s‚Ä≤func(s, Œµy, param)
    Ygrowth = exp(Œîyfunc(Œµy, param))
    R = Rfunc(s, Œµy, param)
    Rf = Rfvec[is]
    w‚Ä≤ = wÃÉ * (Œ∏ * R + (1 - Œ∏) * Rf) / Ygrowth
    Va = Vafunc(w‚Ä≤, s‚Ä≤)
    return Va * Ygrowth^-Œ≥  *  (R - Rf) * wÃÉ^Œ≥
end

function Œ∏foc(Œ∏, wÃÉ, is, funcs, param::HabitParameters)
    param.ùîºŒµy(Œµy -> Œ∏focŒµy(Œ∏, wÃÉ, is, Œµy, funcs, param))
end

function solveŒ∏bywÃÉ!(Œ∏ÃÉmat, Vafunc, param)
    @unpack_HabitParameters param
    # Vafunc = partialinterpolate(agrid, Vamat, Linear())
    for iter in CartesianIndices(Œ∏ÃÉmat)
        ia, is = iter[1], iter[2]
        wÃÉ = agrid[ia]
        try
            Œ∏ÃÉmat[iter] = find_zero(x -> Œ∏foc(x, wÃÉ, is, (Vafunc = Vafunc,), param), (0.0, 30.0), Roots.A42(), tol=1e-5)
        catch
            @show ia, is
            throw(InterruptException())
        end
        # Œ∏ÃÉmat[iter] = find_zero(x -> Œ∏foc(x, wÃÉ, is, (Vafunc = Vafunc,), param), 1.0, tol=1e-5)
    end
    Œ∏ÃÉmat
end

function cfocrhs(Œ∏, wÃÉ, is, Œµy, funcs, param::HabitParameters)
    @unpack Vafunc = funcs
    @unpack_HabitParameters param
    s = sgrid[is]
    s‚Ä≤ = s‚Ä≤func(s, Œµy, param)
    Ygrowth = exp(Œîyfunc(Œµy, param))
    Rf = Rfvec[is]
    R = Rfunc(s, Œµy, param)
    w‚Ä≤ = wÃÉ * (Œ∏ * R + (1 - Œ∏) * Rf) / Ygrowth
    Va = Vafunc(w‚Ä≤, s‚Ä≤)
    return Œ≤ * Va * Ygrowth^-Œ≥  *  R
end

function ùîºcfocrhs(Œ∏, wÃÉ, is, funcs, param::HabitParameters)
    ùîºrhs = param.ùîºŒµy(Œµy->cfocrhs(Œ∏, wÃÉ, is, Œµy, funcs, param))
    return ùîºrhs
end

function solvewbywÃÉ!(wmat, Œ∏ÃÉmat, Vafunc, param::HabitParameters)
    @unpack_HabitParameters param
    # Vafunc = partialinterpolate(agrid, Vamat, Linear())    
    for iter in CartesianIndices(Œ∏ÃÉmat)
        ia, is = iter[1], iter[2]
        wÃÉ, s, S = agrid[ia], sgrid[is], Sgrid[is]
        Œ∏ÃÉ = Œ∏ÃÉmat[iter]
        ùîºrhs = ùîºcfocrhs(Œ∏ÃÉ, wÃÉ, is, (Vafunc = Vafunc,), param)
        c = ùîºrhs^(-1 / Œ≥) + 1 - S
        w = wÃÉ + c + œà - 1
        wmat[iter] = w
    end
    return wmat
end

function interpolatepolicy!(cmat, Œ∏mat, wÃÉmat, wmat, Œ∏ÃÉmat, param::HabitParameters)
    @unpack_HabitParameters param
    Œ∏ÃÉfunc = partialinterpolate(agrid, Œ∏ÃÉmat)
    for is in 1:ns
        s = sgrid[is]
        w_wÃÉ = @view wmat[:, is] # this gives a mapping from wÃÉgrid -> w
        c_w = @view cmat[:, is]
        Œ∏_w = @view Œ∏mat[:, is]
        @assert issorted(w_wÃÉ)
        # if this mapping is monotone, we could take the inverse of this mapping:
        wÃÉ_w = @view wÃÉmat[:, is] # relabel for notational clarity
        wÃÇgrid, wÃÉ_wÃÇ = w_wÃÉ, agrid # relabel it for notational clarity. The mapping wÃÇgrid, wÃÉ_wÃÇ gives the policy function
        sorted_interpolation!(wÃÉ_w, wÃÇgrid, wÃÉ_wÃÇ, agrid)
        Œ∏_w .= Œ∏ÃÉfunc.(wÃÉ_w, is)
        @. c_w =  agrid + 1 - œà - wÃÉ_w
    end
end


function iteratepolicy!(hh, c0::Matrix{T}, param::HabitParameters) where {T}
    @unpack_HabitParameters param
    @unpack_HabitHouseholds hh
    cfunc = extrapolate(interpolate((agrid, sgrid), c0, Gridded(Linear())), Line())
    Vafunc = (w, s) -> (cfunc(w, s) + exp(s) - 1)^-Œ≥
    iteratepolicy!(hh, Vafunc, param)
    return cmat
end

function iteratepolicy!(hh, Vafunc, param::HabitParameters)
    @unpack_HabitHouseholds hh
    solveŒ∏bywÃÉ!(Œ∏ÃÉmat, Vafunc, param)
    solvewbywÃÉ!(wmat, Œ∏ÃÉmat, Vafunc, param)
    interpolatepolicy!(cmat, Œ∏mat, wÃÉmat, wmat, Œ∏ÃÉmat, param)
end

function iterationhelper!(out, x, hh, param::HabitParameters)
    iteratepolicy!(hh, x, param)
    out .= hh.cmat
end



# guess for Lucas models
function guesscwratio(cwratio, ERgamma, param::HabitParameters)
    @unpack_HabitParameters param
    M = cwratio / (1 - cwratio) 
    A = M^-Œ≥ / (Œ≤ * ERgamma)
    A - (M^(1 - Œ≥) + M^-Œ≥) * (1 / (1 + M))^(1 - Œ≥)
end

function solveAandcwratio(param::HabitParameters)
    @unpack_HabitParameters param
    cwratio = zeros(size(sgrid))
    A = zeros(size(sgrid))
    for is in 1:ns
        s = sgrid[is]
        ERgamma = ùîºŒµy(Œµy -> Rfunc(s, Œµy, param)^(1 - Œ≥))
        cwratio[is] = find_zero(x -> guesscwratio(x, ERgamma, param), (1e-8, 1-1e-8), Roots.A42())
        M = cwratio[is] / (1 - cwratio[is]) 
        A[is] = M^-Œ≥ / (Œ≤ * ERgamma)
    end
    return A, cwratio
end

function initializeHH!(hh, param::HabitParameters)
    @unpack_HabitParameters param
    @unpack_HabitHouseholds hh
    Avec, cwratio = solveAandcwratio(param)
    capitalizedŒ© = (1 .- œà) ./ ùîºR
    wgrid = agrid .+ capitalizedŒ©'
    @. cmat = wgrid * cwratio' + 1 - Sgrid'
    # @. cmat = max.(wgrid * cwratio' , 1 + 1e-3)
end



end